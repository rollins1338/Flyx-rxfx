#!/usr/bin/env node
/**
 * Reverse engineer MegaUp encryption - v45
 * 
 * CONFIRMED: Keystream uses plaintext feedback!
 * - Keystrams are identical until position 33
 * - At position 33, encrypted bytes are SAME but plaintext differs
 * - This proves: keystream[i] depends on plaintext[0:i-1]
 * 
 * Now let's figure out the EXACT feedback function.
 * We need to find: keystream[i] = f(state, plaintext[i-1])
 * 
 * Strategy: Use the enc-dec.app API to get correct decryptions,
 * then derive the keystream update function.
 */

const UA = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36';

async function getDecryptedFromAPI(encryptedBase64) {
  const response = await fetch('https://enc-dec.app/api/dec-mega', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: encryptedBase64, agent: UA }),
  });
  const result = await response.json();
  if (result.status !== 200) {
    throw new Error(`API error: ${JSON.stringify(result)}`);
  }
  return typeof result.result === 'string' ? result.result : JSON.stringify(result.result);
}

// Generate test data with known plaintext
async function testWithKnownPlaintext() {
  // We'll use the working video and analyze the keystream generation
  const fs = require('fs');
  
  // Load the saved keystrams
  const working = JSON.parse(fs.readFileSync('megaup-keystream-working.json', 'utf8'));
  const failing = JSON.parse(fs.readFileSync('megaup-keystream-failing.json', 'utf8'));
  
  const wKs = working.keystream;
  const fKs = failing.keystream;
  const wDec = Buffer.from(working.decrypted, 'utf8');
  const fDec = Buffer.from(failing.decrypted, 'utf8');
  
  console.log('=== Analyzing keystream state ===\n');
  
  // The keystream is identical until position 33
  // At position 33, the plaintext differs
  // Let's see what happens to the keystream
  
  // Hypothesis: RC4-like state machine
  // The keystream might be generated by an RC4-like PRNG
  // where the state is updated based on plaintext
  
  // Let's look at the keystream values and see if we can find a pattern
  console.log('First 50 keystream bytes (working):');
  console.log(wKs.slice(0, 50).map(k => k.toString(16).padStart(2, '0')).join(' '));
  
  console.log('\nFirst 50 keystream bytes (failing):');
  console.log(fKs.slice(0, 50).map(k => k.toString(16).padStart(2, '0')).join(' '));
  
  // The first 33 bytes are identical
  // Let's see what the plaintext is at position 32 (the last matching position)
  console.log(`\nPlaintext at position 32: working='${String.fromCharCode(wDec[32])}' (0x${wDec[32].toString(16)}) failing='${String.fromCharCode(fDec[32])}' (0x${fDec[32].toString(16)})`);
  console.log(`Plaintext at position 33: working='${String.fromCharCode(wDec[33])}' (0x${wDec[33].toString(16)}) failing='${String.fromCharCode(fDec[33])}' (0x${fDec[33].toString(16)})`);
  
  // The keystream at position 33 differs
  console.log(`\nKeystream at position 33: working=0x${wKs[33].toString(16)} failing=0x${fKs[33].toString(16)}`);
  console.log(`Keystream at position 32: working=0x${wKs[32].toString(16)} failing=0x${fKs[32].toString(16)}`);
  
  // Let's see if there's a relationship
  // keystream[33] = f(keystream[32], plaintext[32])
  
  const ks32 = wKs[32];
  const plain32_w = wDec[32];
  const plain32_f = fDec[32];
  const ks33_w = wKs[33];
  const ks33_f = fKs[33];
  
  console.log('\n=== Testing feedback functions at position 33 ===\n');
  
  // Test various functions
  console.log(`XOR: ks32 ^ plain32_w = 0x${(ks32 ^ plain32_w).toString(16)} (expected 0x${ks33_w.toString(16)})`);
  console.log(`XOR: ks32 ^ plain32_f = 0x${(ks32 ^ plain32_f).toString(16)} (expected 0x${ks33_f.toString(16)})`);
  
  console.log(`ADD: (ks32 + plain32_w) & 0xFF = 0x${((ks32 + plain32_w) & 0xFF).toString(16)} (expected 0x${ks33_w.toString(16)})`);
  console.log(`ADD: (ks32 + plain32_f) & 0xFF = 0x${((ks32 + plain32_f) & 0xFF).toString(16)} (expected 0x${ks33_f.toString(16)})`);
  
  console.log(`SUB: (ks32 - plain32_w + 256) & 0xFF = 0x${((ks32 - plain32_w + 256) & 0xFF).toString(16)} (expected 0x${ks33_w.toString(16)})`);
  console.log(`SUB: (ks32 - plain32_f + 256) & 0xFF = 0x${((ks32 - plain32_f + 256) & 0xFF).toString(16)} (expected 0x${ks33_f.toString(16)})`);
  
  // Maybe it's not just the previous keystream byte, but some accumulated state
  // Let's look at the difference between the two keystrams at position 33
  
  const ksDiff = (ks33_w - ks33_f + 256) & 0xFF;
  const plainDiff = (plain32_w - plain32_f + 256) & 0xFF;
  
  console.log(`\nKeystream diff at 33: ${ksDiff} (0x${ksDiff.toString(16)})`);
  console.log(`Plaintext diff at 32: ${plainDiff} (0x${plainDiff.toString(16)})`);
  
  // Let's look at cumulative effects
  console.log('\n=== Analyzing cumulative state ===\n');
  
  // Maybe the state is a running sum or XOR of all previous plaintext
  let sumW = 0, sumF = 0;
  let xorW = 0, xorF = 0;
  
  for (let i = 0; i < 33; i++) {
    sumW = (sumW + wDec[i]) & 0xFF;
    sumF = (sumF + fDec[i]) & 0xFF;
    xorW ^= wDec[i];
    xorF ^= fDec[i];
  }
  
  console.log(`Sum of plaintext[0:32]: working=0x${sumW.toString(16)} failing=0x${sumF.toString(16)}`);
  console.log(`XOR of plaintext[0:32]: working=0x${xorW.toString(16)} failing=0x${xorF.toString(16)}`);
  
  // Since plaintext[0:32] is identical, these should be the same
  // The divergence happens at position 33 because plaintext[32] differs
  
  // Let's try a different approach: look at the keystream as an RC4-like stream
  // RC4 has state S[256] and indices i, j
  // Output: j = (j + S[i]) mod 256; swap S[i], S[j]; return S[(S[i] + S[j]) mod 256]
  
  // But with plaintext feedback, it might be:
  // j = (j + S[i] + plaintext[pos]) mod 256
  
  // Let's see if we can derive the initial state from the keystream
  console.log('\n=== Looking for RC4-like patterns ===\n');
  
  // In RC4, the keystream is generated from a 256-byte state array
  // Let's see if we can find any patterns in the keystream
  
  // Check if any keystream bytes repeat
  const ksSet = new Set(wKs.slice(0, 100));
  console.log(`Unique keystream bytes in first 100: ${ksSet.size}`);
  
  // Check the distribution
  const counts = new Array(256).fill(0);
  for (const k of wKs) {
    counts[k]++;
  }
  const nonZero = counts.filter(c => c > 0).length;
  console.log(`Unique keystream bytes total: ${nonZero}`);
  
  // Let's try to find the feedback function by looking at consecutive positions
  console.log('\n=== Testing feedback at multiple positions ===\n');
  
  // For each position, compute what the feedback function would need to be
  // to transform keystream[i-1] to keystream[i] given plaintext[i-1]
  
  for (let i = 1; i < 50; i++) {
    const ks_prev = wKs[i-1];
    const ks_curr = wKs[i];
    const plain_prev = wDec[i-1];
    
    // What operation on (ks_prev, plain_prev) gives ks_curr?
    const xorResult = ks_prev ^ plain_prev;
    const addResult = (ks_prev + plain_prev) & 0xFF;
    const subResult = (ks_prev - plain_prev + 256) & 0xFF;
    const xorAddResult = (ks_prev ^ plain_prev) + plain_prev & 0xFF;
    
    const match = ks_curr === xorResult ? 'XOR' :
                  ks_curr === addResult ? 'ADD' :
                  ks_curr === subResult ? 'SUB' :
                  ks_curr === xorAddResult ? 'XOR+ADD' : 'NONE';
    
    if (match !== 'NONE' || i < 10) {
      console.log(`i=${i.toString().padStart(2)}: ks[${i-1}]=0x${ks_prev.toString(16).padStart(2,'0')} plain[${i-1}]=0x${plain_prev.toString(16).padStart(2,'0')}('${String.fromCharCode(plain_prev)}') -> ks[${i}]=0x${ks_curr.toString(16).padStart(2,'0')} match=${match}`);
    }
  }
  
  // The feedback is clearly not a simple function of just the previous keystream byte
  // It must involve some internal state (like RC4's S-box)
  
  console.log('\n=== Conclusion ===\n');
  console.log('The keystream is NOT a simple function of the previous keystream byte.');
  console.log('It likely uses an internal state (like RC4) that is updated with plaintext feedback.');
  console.log('We need to reverse engineer the JavaScript to find the exact algorithm.');
}

testWithKnownPlaintext().catch(console.error);
