/**
 * Crack Hexa Encryption v26 - Try AES-GCM without auth tag verification
 */

const crypto = require('crypto');

async function crackHexa() {
  console.log('=== Cracking Hexa Encryption v26 ===\n');
  
  const key = crypto.randomBytes(32).toString('hex');
  console.log('Key:', key);
  
  const headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Accept': 'text/plain',
    'X-Api-Key': key,
  };
  
  const url = 'https://themoviedb.hexa.su/api/tmdb/tv/105248/season/1/episode/1/images';
  const encResponse = await fetch(url, { headers });
  const encrypted = await encResponse.text();
  
  const decResponse = await fetch('https://enc-dec.app/api/dec-hexa', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: encrypted, key }),
  });
  const decResult = await decResponse.json();
  const expectedStr = JSON.stringify(decResult.result);
  
  const encBytes = Buffer.from(encrypted, 'base64');
  const expectedBytes = Buffer.from(expectedStr, 'utf8');
  
  console.log('Encrypted bytes:', encBytes.length);
  console.log('Expected bytes:', expectedBytes.length);
  console.log('Overhead:', encBytes.length - expectedBytes.length);
  
  // The overhead is 12 bytes
  // This could be:
  // - 12-byte nonce only (no auth tag) - stream cipher
  // - Something else entirely
  
  const nonce = encBytes.subarray(0, 12);
  const ciphertext = encBytes.subarray(12);
  
  // Extract keystream
  const keystream = Buffer.alloc(ciphertext.length);
  for (let i = 0; i < ciphertext.length; i++) {
    keystream[i] = ciphertext[i] ^ expectedBytes[i];
  }
  
  console.log('Nonce:', nonce.toString('hex'));
  console.log('Keystream[0:32]:', keystream.subarray(0, 32).toString('hex'));
  
  const keyBuf = Buffer.from(key, 'hex');
  
  // AES-GCM internally uses AES-CTR for encryption
  // The keystream is generated by encrypting counter blocks
  // Let's try to match the AES-GCM keystream
  
  console.log('\n=== AES-GCM keystream analysis ===\n');
  
  // In AES-GCM, the counter block is: nonce (12 bytes) || counter (4 bytes)
  // Counter starts at 2 for encryption (1 is used for auth tag)
  
  const keyVariants = [
    { name: 'raw', key: keyBuf },
    { name: 'sha256(str)', key: crypto.createHash('sha256').update(key).digest() },
    { name: 'sha256(bytes)', key: crypto.createHash('sha256').update(keyBuf).digest() },
  ];
  
  for (const { name, key: derivedKey } of keyVariants) {
    // Generate AES-GCM keystream manually
    // Counter block: nonce || counter (big-endian)
    
    for (let startCounter = 0; startCounter <= 2; startCounter++) {
      const generatedKeystream = Buffer.alloc(ciphertext.length);
      let offset = 0;
      let counter = startCounter;
      
      while (offset < ciphertext.length) {
        // Create counter block
        const counterBlock = Buffer.alloc(16);
        nonce.copy(counterBlock, 0);
        counterBlock.writeUInt32BE(counter, 12);
        
        // Encrypt counter block with AES-ECB
        const cipher = crypto.createCipheriv('aes-256-ecb', derivedKey, null);
        cipher.setAutoPadding(false);
        const keystreamBlock = cipher.update(counterBlock);
        
        // Copy to keystream
        const toCopy = Math.min(16, ciphertext.length - offset);
        keystreamBlock.copy(generatedKeystream, offset, 0, toCopy);
        
        offset += 16;
        counter++;
      }
      
      if (generatedKeystream.subarray(0, 32).equals(keystream.subarray(0, 32))) {
        console.log(`*** MATCH: AES-GCM keystream + ${name} + startCounter=${startCounter} ***`);
        
        // Decrypt
        const decrypted = Buffer.alloc(ciphertext.length);
        for (let i = 0; i < ciphertext.length; i++) {
          decrypted[i] = ciphertext[i] ^ generatedKeystream[i];
        }
        console.log('Decrypted:', decrypted.toString('utf8').slice(0, 300));
        return { algorithm: 'aes-gcm-keystream', keyDerivation: name, startCounter };
      }
    }
    
    // Try with little-endian counter
    for (let startCounter = 0; startCounter <= 2; startCounter++) {
      const generatedKeystream = Buffer.alloc(ciphertext.length);
      let offset = 0;
      let counter = startCounter;
      
      while (offset < ciphertext.length) {
        const counterBlock = Buffer.alloc(16);
        nonce.copy(counterBlock, 0);
        counterBlock.writeUInt32LE(counter, 12);
        
        const cipher = crypto.createCipheriv('aes-256-ecb', derivedKey, null);
        cipher.setAutoPadding(false);
        const keystreamBlock = cipher.update(counterBlock);
        
        const toCopy = Math.min(16, ciphertext.length - offset);
        keystreamBlock.copy(generatedKeystream, offset, 0, toCopy);
        
        offset += 16;
        counter++;
      }
      
      if (generatedKeystream.subarray(0, 32).equals(keystream.subarray(0, 32))) {
        console.log(`*** MATCH: AES-GCM keystream (LE) + ${name} + startCounter=${startCounter} ***`);
        return;
      }
    }
  }
  
  // Try with counter at the beginning of the block
  console.log('\n=== Try counter at beginning ===\n');
  
  for (const { name, key: derivedKey } of keyVariants) {
    for (let startCounter = 0; startCounter <= 2; startCounter++) {
      const generatedKeystream = Buffer.alloc(ciphertext.length);
      let offset = 0;
      let counter = startCounter;
      
      while (offset < ciphertext.length) {
        const counterBlock = Buffer.alloc(16);
        counterBlock.writeUInt32BE(counter, 0);
        nonce.copy(counterBlock, 4);
        
        const cipher = crypto.createCipheriv('aes-256-ecb', derivedKey, null);
        cipher.setAutoPadding(false);
        const keystreamBlock = cipher.update(counterBlock);
        
        const toCopy = Math.min(16, ciphertext.length - offset);
        keystreamBlock.copy(generatedKeystream, offset, 0, toCopy);
        
        offset += 16;
        counter++;
      }
      
      if (generatedKeystream.subarray(0, 32).equals(keystream.subarray(0, 32))) {
        console.log(`*** MATCH: AES-CTR (counter first) + ${name} + startCounter=${startCounter} ***`);
        return;
      }
    }
  }
  
  console.log('No match found.');
}

crackHexa().catch(console.error);
