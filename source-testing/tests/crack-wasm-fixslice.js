/**
 * Crack WASM - Understand Fixslice AES
 * 
 * The WASM uses fixslice32 AES implementation from the aes crate.
 * This is a bitsliced implementation that processes data differently.
 * 
 * Let's try to understand how the counter blocks are generated by
 * looking at the CTR mode implementation.
 * 
 * Key insight: CTR mode in ctr-0.9.2 uses ctr32 flavor, which means
 * the counter is a 32-bit value in the last 4 bytes of the 16-byte block.
 */

const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const crypto = require('crypto');

puppeteer.use(StealthPlugin());

async function analyzeFixslice() {
  console.log('=== Analyze Fixslice AES CTR ===\n');
  
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });
  
  const page = await browser.newPage();
  
  await page.goto('https://flixer.sh/watch/tv/106379/1/1', {
    waitUntil: 'networkidle2',
    timeout: 60000,
  });
  
  await page.waitForFunction(() => window.wasmImgData?.ready, { timeout: 30000 });
  
  const testKey = crypto.randomBytes(32).toString('hex');
  console.log(`Test key: ${testKey}\n`);
  
  const result = await page.evaluate(async (key) => {
    const crypto = window.crypto;
    const timestamp = Math.floor(Date.now() / 1000);
    const nonce = btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(16))))
      .replace(/[/+=]/g, '').substring(0, 22);
    
    const encoder = new TextEncoder();
    const keyData = encoder.encode(key);
    const cryptoKey = await crypto.subtle.importKey(
      'raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']
    );
    
    const path = '/api/tmdb/tv/106379/season/1/episode/1/images';
    const message = `${key}:${timestamp}:${nonce}:${path}`;
    const signatureBuffer = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(message));
    const signature = btoa(String.fromCharCode(...new Uint8Array(signatureBuffer)));
    
    const response = await fetch(`https://plsdontscrapemelove.flixer.sh${path}`, {
      headers: {
        'X-Api-Key': key,
        'X-Request-Timestamp': timestamp.toString(),
        'X-Request-Nonce': nonce,
        'X-Request-Signature': signature,
        'X-Client-Fingerprint': 'test',
        'bW90aGFmYWth': '1',
        'X-Only-Sources': '1',
        'X-Server': 'alpha',
      },
    });
    
    const encryptedData = await response.text();
    const decrypted = await window.wasmImgData.process_img_data(encryptedData, key);
    
    return {
      encrypted: encryptedData,
      decrypted: decrypted,
    };
  }, testKey);
  
  await browser.close();
  
  const keyBuf = Buffer.from(testKey, 'hex');
  const encrypted = Buffer.from(result.encrypted, 'base64');
  const decrypted = Buffer.from(result.decrypted);
  
  const overhead = encrypted.length - decrypted.length;
  const prefix = encrypted.slice(0, overhead);
  const ciphertext = encrypted.slice(overhead);
  
  console.log(`Encrypted: ${encrypted.length} bytes`);
  console.log(`Overhead: ${overhead} bytes`);
  console.log(`Ciphertext: ${ciphertext.length} bytes`);
  console.log(`Decrypted: ${decrypted.length} bytes\n`);
  
  // Derive keystream
  const keystream = Buffer.alloc(decrypted.length);
  for (let i = 0; i < decrypted.length; i++) {
    keystream[i] = ciphertext[i] ^ decrypted[i];
  }
  
  // Derive counter blocks
  const counterBlocks = [];
  const numBlocks = Math.ceil(decrypted.length / 16);
  
  for (let block = 0; block < numBlocks; block++) {
    const start = block * 16;
    const end = Math.min(start + 16, keystream.length);
    const keystreamBlock = keystream.slice(start, end);
    
    const padded = Buffer.alloc(16);
    keystreamBlock.copy(padded);
    
    const decipher = crypto.createDecipheriv('aes-256-ecb', keyBuf, null);
    decipher.setAutoPadding(false);
    const counterBlock = decipher.update(padded);
    counterBlocks.push(counterBlock);
  }
  
  console.log('Counter blocks:');
  for (let i = 0; i < counterBlocks.length; i++) {
    const cb = counterBlocks[i];
    // Show as: [nonce 12 bytes] [counter 4 bytes]
    const nonce12 = cb.slice(0, 12);
    const counter32 = cb.readUInt32BE(12);
    console.log(`  ${i}: ${cb.toString('hex')} | nonce=${nonce12.toString('hex')} counter=${counter32}`);
  }
  
  // Check if the last 4 bytes increment
  console.log('\n=== Counter Increment Analysis ===\n');
  
  for (let i = 0; i < counterBlocks.length - 1; i++) {
    const cb1 = counterBlocks[i];
    const cb2 = counterBlocks[i + 1];
    
    // Check if first 12 bytes are the same
    const nonce1 = cb1.slice(0, 12);
    const nonce2 = cb2.slice(0, 12);
    const sameNonce = nonce1.equals(nonce2);
    
    // Check counter difference
    const counter1 = cb1.readUInt32BE(12);
    const counter2 = cb2.readUInt32BE(12);
    const counterDiff = counter2 - counter1;
    
    console.log(`Block ${i} -> ${i+1}: same_nonce=${sameNonce}, counter_diff=${counterDiff}`);
  }
  
  // The counter blocks are completely random, which means either:
  // 1. The nonce changes for each block (unusual)
  // 2. The counter is not in the last 4 bytes
  // 3. The encryption is not standard CTR mode
  
  // Let's check if the counter blocks have any common bytes
  console.log('\n=== Common Bytes Analysis ===\n');
  
  for (let bytePos = 0; bytePos < 16; bytePos++) {
    const bytes = counterBlocks.map(cb => cb[bytePos]);
    const unique = new Set(bytes);
    
    if (unique.size === 1) {
      console.log(`Byte ${bytePos}: constant value 0x${bytes[0].toString(16).padStart(2, '0')}`);
    } else if (unique.size < counterBlocks.length / 2) {
      console.log(`Byte ${bytePos}: ${unique.size} unique values`);
    }
  }
  
  // Let's try to find if the counter blocks are derived from the prefix
  console.log('\n=== Prefix-Counter Relationship ===\n');
  
  // Maybe the counter blocks are encrypted versions of prefix segments
  for (let i = 0; i < Math.min(counterBlocks.length, 5); i++) {
    const cb = counterBlocks[i];
    
    // Check if cb = AES(key, prefix[i*16:(i+1)*16])
    if ((i + 1) * 16 <= prefix.length) {
      const prefixSegment = prefix.slice(i * 16, (i + 1) * 16);
      
      const cipher = crypto.createCipheriv('aes-256-ecb', keyBuf, null);
      cipher.setAutoPadding(false);
      const encrypted = cipher.update(prefixSegment);
      
      if (encrypted.equals(cb)) {
        console.log(`Counter block ${i} = AES(key, prefix[${i*16}:${(i+1)*16}])`);
      }
      
      // Check if cb = prefix[i*16:(i+1)*16] XOR something
      const xored = Buffer.alloc(16);
      for (let j = 0; j < 16; j++) {
        xored[j] = cb[j] ^ prefixSegment[j];
      }
      console.log(`CB${i} XOR prefix[${i*16}:${(i+1)*16}] = ${xored.toString('hex')}`);
    }
  }
  
  // Maybe the prefix contains the keystream directly (encrypted with a different key)
  console.log('\n=== Keystream in Prefix? ===\n');
  
  // Check if keystream appears in prefix
  for (let pos = 0; pos <= prefix.length - 16; pos++) {
    if (prefix.slice(pos, pos + 16).equals(keystream.slice(0, 16))) {
      console.log(`Keystream[0:16] found at prefix[${pos}:${pos+16}]`);
    }
  }
  
  // Check if keystream XOR key appears in prefix
  const keystreamXorKey = Buffer.alloc(16);
  for (let i = 0; i < 16; i++) {
    keystreamXorKey[i] = keystream[i] ^ keyBuf[i];
  }
  
  for (let pos = 0; pos <= prefix.length - 16; pos++) {
    if (prefix.slice(pos, pos + 16).equals(keystreamXorKey)) {
      console.log(`Keystream[0:16] XOR key[0:16] found at prefix[${pos}:${pos+16}]`);
    }
  }
}

analyzeFixslice().catch(console.error);
