/**
 * Deep analysis of MegaUp encryption
 * 
 * Let's work backwards from what we know:
 * - Input: base64url decoded bytes
 * - Output: JSON like {"file":"https://..."}
 * - Key: likely derived from UA
 * 
 * Let me find the exact relationship between input and output bytes
 */

const HEADERS = {
  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36',
};

function b64UrlDecode(str) {
  let b64 = str.replace(/-/g, '+').replace(/_/g, '/');
  while (b64.length % 4) b64 += '=';
  return Buffer.from(b64, 'base64');
}

async function main() {
  const response = await fetch('https://megaup22.online/e/18ryYD7yWS2JcOLzFLxK6hXpCQ', {
    headers: { ...HEADERS, 'Referer': 'https://animekai.to/' },
  });
  const html = await response.text();
  
  const pageDataMatch = html.match(/window\.__PAGE_DATA\s*=\s*"([^"]+)"/);
  const pageData = pageDataMatch[1];
  const uaMatch = html.match(/var\s+ua\s*=\s*['"]([^'"]+)['"]/);
  const ua = uaMatch[1];
  
  const decoded = b64UrlDecode(pageData);
  const enc = Array.from(decoded);
  
  // Expected output format: {"file":"https://cdn...m3u8","label":"auto"}
  // Let's assume the structure and work backwards
  const expectedStart = '{"file":"https://';
  const plain = expectedStart.split('').map(c => c.charCodeAt(0));
  
  console.log('Encrypted:', enc.slice(0, 20));
  console.log('Expected: ', plain);
  console.log('UA bytes: ', ua.slice(0, 20).split('').map(c => c.charCodeAt(0)));
  console.log('');
  
  // For each position, calculate what operation would transform enc[i] to plain[i]
  console.log('=== Byte-by-byte analysis ===\n');
  
  for (let i = 0; i < Math.min(plain.length, enc.length); i++) {
    const e = enc[i];
    const p = plain[i];
    const u = ua.charCodeAt(i % ua.length);
    
    // Calculate the "key byte" that would XOR e to p
    const xorKey = e ^ p;
    
    // Calculate the "add key" that would add to e to get p
    const addKey = (p - e + 256) % 256;
    
    // Calculate the "sub key" that would subtract from e to get p
    const subKey = (e - p + 256) % 256;
    
    console.log(`Pos ${i.toString().padStart(2)}: enc=${e.toString().padStart(3)}, plain=${p.toString().padStart(3)} ('${String.fromCharCode(p)}'), ua=${u.toString().padStart(3)} ('${ua[i]}')`);
    console.log(`         XOR key=${xorKey.toString().padStart(3)}, ADD key=${addKey.toString().padStart(3)}, SUB key=${subKey.toString().padStart(3)}`);
    
    // Check if key relates to UA
    if (xorKey === u) console.log('         ✓ XOR key == UA byte');
    if (addKey === u) console.log('         ✓ ADD key == UA byte');
    if (subKey === u) console.log('         ✓ SUB key == UA byte');
    if ((xorKey ^ 131) === u) console.log('         ✓ XOR key ^ 131 == UA byte');
    if ((addKey + 131) % 256 === u) console.log('         ✓ (ADD key + 131) == UA byte');
    if ((subKey - 131 + 256) % 256 === u) console.log('         ✓ (SUB key - 131) == UA byte');
    
    console.log('');
  }
  
  // Look for patterns in the XOR keys
  console.log('=== XOR key pattern analysis ===\n');
  
  const xorKeys = [];
  for (let i = 0; i < Math.min(plain.length, enc.length); i++) {
    xorKeys.push(enc[i] ^ plain[i]);
  }
  console.log('XOR keys:', xorKeys);
  
  // Check if XOR keys follow a pattern
  const diffs = [];
  for (let i = 1; i < xorKeys.length; i++) {
    diffs.push((xorKeys[i] - xorKeys[i-1] + 256) % 256);
  }
  console.log('Key diffs:', diffs);
  
  // Check relationship with UA
  const uaBytes = ua.split('').map(c => c.charCodeAt(0));
  console.log('\nXOR key vs UA byte:');
  for (let i = 0; i < xorKeys.length; i++) {
    const u = uaBytes[i % uaBytes.length];
    const diff = (xorKeys[i] - u + 256) % 256;
    const xorDiff = xorKeys[i] ^ u;
    console.log(`  ${i}: key=${xorKeys[i]}, ua=${u}, diff=${diff}, xor=${xorDiff}`);
  }
  
  // Maybe the key is generated by some PRNG seeded with UA
  console.log('\n=== PRNG analysis ===\n');
  
  // Check if keys follow a linear congruential generator pattern
  // LCG: next = (a * current + c) mod m
  // Try to find a, c, m
  
  // Simple approach: check if key[i+1] = f(key[i]) for some simple f
  console.log('Checking if keys follow LCG pattern...');
  
  for (let a = 1; a < 256; a += 2) { // a should be odd for full period
    for (let c = 0; c < 256; c++) {
      let matches = true;
      for (let i = 0; i < xorKeys.length - 1; i++) {
        const predicted = (a * xorKeys[i] + c) % 256;
        if (predicted !== xorKeys[i + 1]) {
          matches = false;
          break;
        }
      }
      if (matches) {
        console.log(`  Found LCG: a=${a}, c=${c}`);
      }
    }
  }
  
  // Check if keys are derived from UA hash
  console.log('\nChecking hash-based derivation...');
  
  // Try: key[i] = hash(ua, i)
  function hashWithIndex(str, idx) {
    let h = 0;
    for (let i = 0; i < str.length; i++) {
      h = ((h << 5) - h + str.charCodeAt(i) + idx) & 0xFF;
    }
    return h;
  }
  
  let hashMatch = true;
  for (let i = 0; i < xorKeys.length; i++) {
    const h = hashWithIndex(ua, i);
    if (h !== xorKeys[i]) {
      hashMatch = false;
    }
  }
  console.log('Hash with index match:', hashMatch);
  
  // Try: cumulative hash
  function cumulativeHash(str, len) {
    const result = [];
    let h = 0;
    for (let i = 0; i < len; i++) {
      h = (h + str.charCodeAt(i % str.length)) & 0xFF;
      result.push(h);
    }
    return result;
  }
  
  const cumHash = cumulativeHash(ua, xorKeys.length);
  console.log('Cumulative hash:', cumHash);
  console.log('XOR keys:       ', xorKeys);
  
  // Check XOR between cumHash and xorKeys
  const cumXor = xorKeys.map((k, i) => k ^ cumHash[i]);
  console.log('cumHash XOR keys:', cumXor);
}

main().catch(console.error);
