/**
 * Reverse engineer the key by analyzing multiple samples
 * 
 * If we can get multiple encrypted/decrypted pairs, we can find the pattern
 */

const HEADERS = {
  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36',
};

function b64UrlDecode(str) {
  let b64 = str.replace(/-/g, '+').replace(/_/g, '/');
  while (b64.length % 4) b64 += '=';
  return Buffer.from(b64, 'base64');
}

async function main() {
  // The XOR keys we found: [164, 33, 104, 69, 159, 231, 52, 160, 244, 234, 35, 64, 175, 178, 169, 206, 196]
  // These are the bytes that XOR the encrypted data to get the plaintext
  
  // Let me analyze these keys themselves
  const xorKeys = [164, 33, 104, 69, 159, 231, 52, 160, 244, 234, 35, 64, 175, 178, 169, 206, 196];
  
  console.log('Analyzing XOR key sequence...\n');
  console.log('Keys:', xorKeys);
  console.log('');
  
  // Binary representation
  console.log('Binary:');
  xorKeys.forEach((k, i) => {
    console.log(`  ${i}: ${k.toString(2).padStart(8, '0')} (${k})`);
  });
  
  // Check for bit patterns
  console.log('\nBit analysis:');
  for (let bit = 0; bit < 8; bit++) {
    const bits = xorKeys.map(k => (k >> bit) & 1);
    console.log(`  Bit ${bit}: ${bits.join('')}`);
  }
  
  // The key might be generated by a LFSR (Linear Feedback Shift Register)
  console.log('\nChecking LFSR patterns...');
  
  // Try to find LFSR taps that generate this sequence
  // For 8-bit LFSR, common taps are at positions 8,6,5,4 or 8,4,3,2
  
  function lfsr8(seed, taps, len) {
    const result = [];
    let state = seed;
    for (let i = 0; i < len; i++) {
      result.push(state);
      let bit = 0;
      for (const tap of taps) {
        bit ^= (state >> tap) & 1;
      }
      state = ((state << 1) | bit) & 0xFF;
    }
    return result;
  }
  
  // Try different seeds and tap configurations
  const tapConfigs = [
    [7, 5, 4, 3],
    [7, 6, 5, 4],
    [7, 6, 4, 2],
    [7, 5, 3, 1],
    [7, 6, 5, 2],
    [7, 4, 3, 2],
    [7, 6, 3, 1],
    [7, 5, 4, 0],
  ];
  
  for (const taps of tapConfigs) {
    for (let seed = 0; seed < 256; seed++) {
      const generated = lfsr8(seed, taps, xorKeys.length);
      let matches = 0;
      for (let i = 0; i < xorKeys.length; i++) {
        if (generated[i] === xorKeys[i]) matches++;
      }
      if (matches > 5) {
        console.log(`  Taps [${taps}], seed ${seed}: ${matches} matches`);
      }
    }
  }
  
  // Maybe it's a simple counter with XOR
  console.log('\nChecking counter-based patterns...');
  
  // key[i] = (seed + i) XOR constant
  for (let seed = 0; seed < 256; seed++) {
    for (let c = 0; c < 256; c++) {
      let matches = 0;
      for (let i = 0; i < xorKeys.length; i++) {
        if (((seed + i) ^ c) === xorKeys[i]) matches++;
      }
      if (matches > 10) {
        console.log(`  seed=${seed}, xor=${c}: ${matches} matches`);
      }
    }
  }
  
  // key[i] = (seed * i) XOR constant
  for (let seed = 1; seed < 256; seed++) {
    for (let c = 0; c < 256; c++) {
      let matches = 0;
      for (let i = 0; i < xorKeys.length; i++) {
        if ((((seed * i) & 0xFF) ^ c) === xorKeys[i]) matches++;
      }
      if (matches > 10) {
        console.log(`  mult seed=${seed}, xor=${c}: ${matches} matches`);
      }
    }
  }
  
  // Maybe the key is just a fixed sequence that's the same for all videos
  // Let me fetch another video and compare
  console.log('\nFetching another video to compare keys...');
  
  // Try a different video ID
  const videos = [
    'https://megaup22.online/e/18ryYD7yWS2JcOLzFLxK6hXpCQ', // Original
    'https://megaup.live/e/18ryYD7yWSyJcOLzFLxK6hXpCQ',    // Alternative domain
  ];
  
  for (const url of videos) {
    try {
      const response = await fetch(url, {
        headers: { ...HEADERS, 'Referer': 'https://animekai.to/' },
      });
      
      if (!response.ok) {
        console.log(`  ${url}: HTTP ${response.status}`);
        continue;
      }
      
      const html = await response.text();
      const pageDataMatch = html.match(/window\.__PAGE_DATA\s*=\s*"([^"]+)"/);
      
      if (!pageDataMatch) {
        console.log(`  ${url}: No PAGE_DATA found`);
        continue;
      }
      
      const pageData = pageDataMatch[1];
      const decoded = b64UrlDecode(pageData);
      
      console.log(`  ${url.substring(0, 40)}...`);
      console.log(`    PAGE_DATA: ${pageData.substring(0, 40)}...`);
      console.log(`    Decoded length: ${decoded.length}`);
      console.log(`    First 10 bytes: ${Array.from(decoded.slice(0, 10))}`);
    } catch (e) {
      console.log(`  ${url}: Error - ${e.message}`);
    }
  }
  
  // The decryption might use a lookup table
  console.log('\nChecking if keys form a substitution cipher...');
  
  // Check if keys are a permutation of 0-255
  const uniqueKeys = new Set(xorKeys);
  console.log(`  Unique keys: ${uniqueKeys.size} / ${xorKeys.length}`);
  
  // Check if there's a mathematical relationship between consecutive keys
  console.log('\nConsecutive key relationships:');
  for (let i = 1; i < xorKeys.length; i++) {
    const diff = (xorKeys[i] - xorKeys[i-1] + 256) % 256;
    const xorDiff = xorKeys[i] ^ xorKeys[i-1];
    const ratio = xorKeys[i-1] !== 0 ? (xorKeys[i] / xorKeys[i-1]).toFixed(2) : 'inf';
    console.log(`  ${i-1}->${i}: diff=${diff}, xor=${xorDiff}, ratio=${ratio}`);
  }
}

main().catch(console.error);
