/**
 * Crack Flixer.sh - V13
 * 
 * Final attempt: Let's try to use an external decryption service
 * or find a pattern by making many requests and analyzing them.
 * 
 * Also, let's check if maybe the encryption is simpler than we thought:
 * - Maybe it's just XOR with a keystream derived from the API key
 * - The keystream might be generated by a CSPRNG seeded with the API key
 */

const crypto = require('crypto');
const https = require('https');

const API_BASE = 'https://plsdontscrapemelove.flixer.sh';

function generateNonce() {
  return crypto.randomBytes(16).toString('base64').replace(/[/+=]/g, '').substring(0, 22);
}

function generateSignature(key, timestamp, nonce, urlPath) {
  return crypto.createHmac('sha256', key).update(`${key}:${timestamp}:${nonce}:${urlPath}`).digest('base64');
}

function makeRequest(urlPath, key, extraHeaders = {}) {
  const timestamp = Math.floor(Date.now() / 1000);
  const nonce = generateNonce();
  const signature = generateSignature(key, timestamp, nonce, urlPath);
  
  const headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Accept': 'text/plain',
    'Origin': 'https://flixer.sh',
    'Referer': 'https://flixer.sh/',
    'X-Api-Key': key,
    'X-Request-Timestamp': timestamp.toString(),
    'X-Request-Nonce': nonce,
    'X-Request-Signature': signature,
    'X-Client-Fingerprint': 'jnurg',
    'bW90aGFmYWth': '1',
    ...extraHeaders,
  };
  
  return new Promise((resolve, reject) => {
    https.get(`${API_BASE}${urlPath}`, { headers }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => resolve({ status: res.statusCode, data }));
    }).on('error', reject);
  });
}

/**
 * The WASM uses Math.random() - maybe the keystream includes randomness
 * that's seeded by the API key.
 * 
 * Let's check if the response includes a seed/nonce that we need to use.
 */
async function analyzeResponseStructure() {
  console.log('=== Analyze Response Structure ===\n');
  
  const testPath = '/api/tmdb/tv/106379/season/1/episode/1/images';
  
  // Make multiple requests with the SAME key
  const apiKey = crypto.randomBytes(32).toString('hex');
  console.log(`API Key: ${apiKey}\n`);
  
  const responses = [];
  for (let i = 0; i < 5; i++) {
    const res = await makeRequest(testPath, apiKey, { 'X-Only-Sources': '1', 'X-Server': 'alpha' });
    responses.push(Buffer.from(res.data, 'base64'));
    console.log(`Response ${i + 1}: ${res.data.substring(0, 30)}... (${responses[i].length} bytes)`);
    await new Promise(r => setTimeout(r, 300));
  }
  
  // All responses should be the same length
  console.log(`\nLengths: ${responses.map(r => r.length).join(', ')}`);
  
  // Check byte-by-byte similarity
  const minLen = Math.min(...responses.map(r => r.length));
  let sameCount = 0;
  
  for (let i = 0; i < minLen; i++) {
    const allSame = responses.every(r => r[i] === responses[0][i]);
    if (allSame) sameCount++;
  }
  
  console.log(`Same bytes: ${sameCount}/${minLen} (${(sameCount/minLen*100).toFixed(1)}%)`);
  
  // If 0% same, the encryption uses a random nonce each time
  // The nonce must be embedded in the response
  
  // Let's find where the randomness is by XORing responses
  if (sameCount === 0) {
    console.log('\nAll bytes differ - encryption uses random nonce');
    
    // XOR consecutive responses to find patterns
    const xor01 = Buffer.alloc(minLen);
    for (let i = 0; i < minLen; i++) {
      xor01[i] = responses[0][i] ^ responses[1][i];
    }
    
    console.log(`XOR(r0, r1) first 32 bytes: ${xor01.subarray(0, 32).toString('hex')}`);
    
    // In CTR mode with random nonce:
    // c0 = p XOR AES(k, n0 || ctr)
    // c1 = p XOR AES(k, n1 || ctr)
    // c0 XOR c1 = AES(k, n0 || ctr) XOR AES(k, n1 || ctr)
    // This should look random
  }
}

/**
 * Let's try to find the nonce by assuming it's at a specific position
 * and the rest is standard AES-CTR
 */
async function bruteForceNoncePosition() {
  console.log('\n=== Brute Force Nonce Position ===\n');
  
  const testPath = '/api/tmdb/tv/106379/season/1/episode/1/images';
  const apiKey = crypto.randomBytes(32).toString('hex');
  
  const res = await makeRequest(testPath, apiKey, { 'X-Only-Sources': '1', 'X-Server': 'alpha' });
  const data = Buffer.from(res.data, 'base64');
  const apiKeyBuf = Buffer.from(apiKey, 'hex');
  
  console.log(`API Key: ${apiKey}`);
  console.log(`Data: ${data.length} bytes`);
  
  // Try every possible nonce position (0 to data.length - 16)
  // This is expensive but might find the answer
  
  const knownStart = '{"sources":[{"server":"alpha"';
  
  for (let noncePos = 0; noncePos < Math.min(64, data.length - 16); noncePos++) {
    const nonce = data.subarray(noncePos, noncePos + 16);
    
    // Build ciphertext (everything except the nonce)
    const ciphertext = Buffer.concat([
      data.subarray(0, noncePos),
      data.subarray(noncePos + 16)
    ]);
    
    // Try to decrypt
    try {
      const decipher = crypto.createDecipheriv('aes-256-ctr', apiKeyBuf, nonce);
      let decrypted = decipher.update(ciphertext);
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      
      const text = decrypted.toString('utf8');
      
      if (text.startsWith(knownStart)) {
        console.log(`*** SUCCESS: nonce at position ${noncePos} ***`);
        console.log(text);
        return { noncePos };
      }
    } catch (e) {
      // Ignore
    }
  }
  
  console.log('No nonce position worked');
  return null;
}

/**
 * Maybe the encryption is AES-GCM (authenticated encryption)
 * Format: nonce (12 bytes) || ciphertext || tag (16 bytes)
 */
async function tryAesGcm() {
  console.log('\n=== Try AES-GCM ===\n');
  
  const testPath = '/api/tmdb/tv/106379/season/1/episode/1/images';
  const apiKey = crypto.randomBytes(32).toString('hex');
  
  const res = await makeRequest(testPath, apiKey, { 'X-Only-Sources': '1', 'X-Server': 'alpha' });
  const data = Buffer.from(res.data, 'base64');
  const apiKeyBuf = Buffer.from(apiKey, 'hex');
  
  console.log(`API Key: ${apiKey}`);
  console.log(`Data: ${data.length} bytes`);
  
  // Try: nonce (12) || ciphertext || tag (16)
  const nonce = data.subarray(0, 12);
  const tag = data.subarray(-16);
  const ciphertext = data.subarray(12, -16);
  
  console.log(`Nonce: ${nonce.toString('hex')}`);
  console.log(`Tag: ${tag.toString('hex')}`);
  console.log(`Ciphertext: ${ciphertext.length} bytes`);
  
  try {
    const decipher = crypto.createDecipheriv('aes-256-gcm', apiKeyBuf, nonce);
    decipher.setAuthTag(tag);
    let decrypted = decipher.update(ciphertext);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    
    const text = decrypted.toString('utf8');
    console.log(`Decrypted: ${text.substring(0, 100)}`);
    
    if (text.startsWith('{')) {
      console.log('\n*** SUCCESS! ***');
      console.log(text);
      return true;
    }
  } catch (e) {
    console.log(`GCM error: ${e.message}`);
  }
  
  // Try with tag at the beginning
  const nonce2 = data.subarray(0, 12);
  const tag2 = data.subarray(12, 28);
  const ciphertext2 = data.subarray(28);
  
  try {
    const decipher = crypto.createDecipheriv('aes-256-gcm', apiKeyBuf, nonce2);
    decipher.setAuthTag(tag2);
    let decrypted = decipher.update(ciphertext2);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    
    const text = decrypted.toString('utf8');
    console.log(`Decrypted (tag first): ${text.substring(0, 100)}`);
    
    if (text.startsWith('{')) {
      console.log('\n*** SUCCESS! ***');
      console.log(text);
      return true;
    }
  } catch (e) {
    console.log(`GCM (tag first) error: ${e.message}`);
  }
  
  return false;
}

/**
 * Let's try ChaCha20-Poly1305 (another authenticated cipher)
 */
async function tryChaCha20Poly1305() {
  console.log('\n=== Try ChaCha20-Poly1305 ===\n');
  
  const testPath = '/api/tmdb/tv/106379/season/1/episode/1/images';
  const apiKey = crypto.randomBytes(32).toString('hex');
  
  const res = await makeRequest(testPath, apiKey, { 'X-Only-Sources': '1', 'X-Server': 'alpha' });
  const data = Buffer.from(res.data, 'base64');
  const apiKeyBuf = Buffer.from(apiKey, 'hex');
  
  // ChaCha20-Poly1305: nonce (12) || ciphertext || tag (16)
  const nonce = data.subarray(0, 12);
  const tag = data.subarray(-16);
  const ciphertext = data.subarray(12, -16);
  
  try {
    const decipher = crypto.createDecipheriv('chacha20-poly1305', apiKeyBuf, nonce, { authTagLength: 16 });
    decipher.setAuthTag(tag);
    let decrypted = decipher.update(ciphertext);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    
    const text = decrypted.toString('utf8');
    console.log(`Decrypted: ${text.substring(0, 100)}`);
    
    if (text.startsWith('{')) {
      console.log('\n*** SUCCESS! ***');
      console.log(text);
      return true;
    }
  } catch (e) {
    console.log(`ChaCha20-Poly1305 error: ${e.message}`);
  }
  
  return false;
}

/**
 * Final attempt: Maybe the server uses a completely custom scheme
 * where each byte is encrypted independently with a different key
 */
async function tryPerByteEncryption() {
  console.log('\n=== Try Per-Byte Encryption ===\n');
  
  const testPath = '/api/tmdb/tv/106379/season/1/episode/1/images';
  const apiKey = crypto.randomBytes(32).toString('hex');
  
  const res = await makeRequest(testPath, apiKey, { 'X-Only-Sources': '1', 'X-Server': 'alpha' });
  const data = Buffer.from(res.data, 'base64');
  const apiKeyBuf = Buffer.from(apiKey, 'hex');
  
  // Generate a long keystream using HKDF-like expansion
  const keystream = Buffer.alloc(data.length);
  
  // Method 1: HMAC-based expansion
  let offset = 0;
  let counter = 1;
  let prevBlock = Buffer.alloc(0);
  
  while (offset < data.length) {
    const counterBuf = Buffer.from([counter]);
    const input = Buffer.concat([prevBlock, apiKeyBuf, counterBuf]);
    const block = crypto.createHmac('sha256', apiKeyBuf).update(input).digest();
    
    const copyLen = Math.min(32, data.length - offset);
    block.copy(keystream, offset, 0, copyLen);
    
    prevBlock = block;
    offset += copyLen;
    counter++;
  }
  
  const decrypted = Buffer.alloc(data.length);
  for (let i = 0; i < data.length; i++) {
    decrypted[i] = data[i] ^ keystream[i];
  }
  
  const text = decrypted.toString('utf8');
  console.log(`HKDF-like expansion result: ${text.substring(0, 100)}`);
  
  if (text.startsWith('{')) {
    console.log('\n*** SUCCESS! ***');
    console.log(text);
    return true;
  }
  
  return false;
}

async function main() {
  await analyzeResponseStructure();
  await bruteForceNoncePosition();
  await tryAesGcm();
  await tryChaCha20Poly1305();
  await tryPerByteEncryption();
  
  console.log('\n=== Summary ===');
  console.log('Unable to crack the encryption with pure JavaScript.');
  console.log('The WASM uses a custom encryption scheme that we cannot replicate.');
  console.log('\nOptions:');
  console.log('1. Use Puppeteer to run the WASM in a browser context');
  console.log('2. Find an external decryption service');
  console.log('3. Reverse engineer the WASM binary more deeply');
}

main().catch(console.error);
